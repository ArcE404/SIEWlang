namespace GenerateAst;

using System.Text;
using SystemEnv = Environment;

// ***************************************************
// Sometimes It Even Works (SIEW) Programming Language
// Code generator feature:
// This generates the Expr class with all the necessay code
// ***************************************************
class Program
{
    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.WriteLine("Usage: generate_ast <output directory>");
            SystemEnv.Exit(64);
        }

        string outputDir = args[0];

        DefineAst(outputDir, "Expr", new()
        {
            "Binary   : Expr Left, Token Operator, Expr Right",
            "Grouping : Expr Expression",
            "Literal  : Object Value",
            "Unary    : Token Operator, Expr Right"
        }
        );
    }

    private static void DefineAst(string outputDir, string baseName, List<string> types) 
    {
        string path = outputDir + "/" + baseName + ".cs";
        using var writer = new StreamWriter(path, false, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));

        writer.WriteLine("using SIEWlang.Core.Lexer;");
        writer.WriteLine("namespace SIEWlang.Core.Parser;");
        writer.WriteLine();
        writer.WriteLine("// ***************************************************");
        writer.WriteLine("// This code is autogenerated by the GenerateAst Tool.");
        writer.WriteLine("// ***************************************************");
        writer.WriteLine();



        writer.WriteLine("abstract class " + baseName + "{");
        writer.WriteLine("    public abstract T Accept<T>(IVisitor<T> visitor);");
        writer.WriteLine();
        DefineVisitor(writer, "Expr", types);
        writer.WriteLine();

        foreach(var type in types)
        {
            string className = type.Split(':')[0].Trim();
            string fields = type.Split(":")[1].Trim();
            DefineType(writer, baseName, className, fields);
        }

        writer.WriteLine("}");

    }

    private static void DefineType(
    StreamWriter writer, string baseName,
    string className, string fieldList)
    {
        writer.WriteLine($"   public class {className} : {baseName}");
        writer.WriteLine("   {");

        // Campos
        var fields = fieldList.Split(", ");
        foreach (var field in fields)
        {
            writer.WriteLine($"        public {field} {{ get; }}");
        }

        writer.WriteLine();

        // Constructor
        writer.WriteLine($"        public {className}({fieldList})");
        writer.WriteLine("        {");
        foreach (var field in fields)
        {
            var name = field.Split(' ')[1];
            writer.WriteLine($"            this.{name} = {name};");
        }
        writer.WriteLine("        }");

        writer.WriteLine();

        // define abstract overrides
        writer.WriteLine("        public override T Accept<T>(IVisitor<T> visitor)");
        writer.WriteLine("        {");
        writer.WriteLine($"            return visitor.Visit{className}{baseName}(this);");
        writer.WriteLine("        }");


        writer.WriteLine("   }");
        writer.WriteLine();
    }

    private static void DefineVisitor(
    StreamWriter writer, string baseName, List<string> types)
    {
        writer.WriteLine($"    public interface IVisitor<R>");
        writer.WriteLine("    {");

        foreach (var type in types)
        {
            var typeName = type.Split(":")[0].Trim();
            writer.WriteLine($"        R Visit{typeName}{baseName}({typeName} {baseName.ToLower()});");
        }

        writer.WriteLine("    }");
    }

}